#!/bin/bash

# shellcheck source=../lib-init-mock.bash
source ./lib-init-mock.bash

# External mock to allow error handling inside `if pacman ...`

function pacman() {
	local command=
	local subcommand=
	local args=()
	local opt_quiet=false
	local opt_explicit=false
	local opt_deps=false
	local opt_native=false
	local opt_foreign=false
	local opt_unrequired=0
	local opt_asdeps=false
	local opt_asexplicit=false

	local arg
	for arg in "$@"
	do
		case "$arg" in
			--query|--sync|--database|--remove)
				command=${arg#--}
				;;
			--list|--info)
				subcommand=${arg#--}
				;;
			--quiet)
				opt_quiet=true
				;;
			--explicit)
				opt_explicit=true
				;;
			--deps)
				opt_deps=true
				;;
			--native)
				opt_native=true
				;;
			--foreign)
				opt_foreign=true
				;;
			--unrequired)
				opt_unrequired=$((opt_unrequired+1))
				;;
			--asdeps)
				opt_asdeps=true
				;;
			--asexplicit)
				opt_asexplicit=true
				;;
			--*)
				FatalError 'Unknown mocked pacman switch %s\n' "$(Color Y "$arg")"
				;;
			*)
				args+=("$arg")
		esac
	done

	case "$command" in
		query)
			case "$subcommand" in
				'')
					$opt_quiet || FatalError 'Mocked pacman --query without --quiet\n'

					local name kind inst_as
					while IFS=$'\t' read -r name kind inst_as
					do
						if $opt_native && [[ "$kind" != native ]]
						then
							continue
						fi

						if $opt_foreign && [[ "$kind" != foreign ]]
						then
							continue
						fi

						if $opt_explicit && [[ "$inst_as" != explicit ]]
						then
							continue
						fi

						if $opt_deps && [[ "$inst_as" == explicit ]]
						then
							continue
						fi

						if [[ $opt_unrequired -eq 2 && "$inst_as" != orphan ]]
						then
							continue
						fi

						printf "%s\n" "$name"
					done < "$test_data_dir"/packages.txt
					;;
				info)
					local package
					for package in "${args[@]}"
					do
						printf 'Name            : %s\n' "$package"
						printf 'Description     : %s\n' "Dummy aconfmgr test suite package"
						printf '\n'
					done
					;;
				list)
					$opt_quiet || FatalError 'Mocked pacman --query --list without --quiet\n'

					local package
					find "$test_data_dir"/packages -mindepth 1 -maxdepth 1 -printf '%P\0' | \
						while read -r -d $'\0' package
						do
							find "$test_data_dir"/packages/"$package"/files \
								 -mindepth 1 \
								 -printf '%P\n' \
								| sed 's#^#/#'
						done \
							| sort -u
					;;
				*)
					FatalError 'Unknown --query subcommand %s\n' "$subcommand"
					;;
			esac
			;;
		sync)
			local arg
			for arg in "${args[@]}"
			do
				printf 'install %s\n' "$arg" >> "$test_data_dir"/pacman-actions.txt
			done
			;;
		database)
			local arg
			for arg in "${args[@]}"
			do
				if $opt_asdeps
				then
					printf 'unpin %s\n' "$arg" >> "$test_data_dir"/pacman-actions.txt
				elif $opt_asexplicit
				then
					printf 'pin %s\n' "$arg" >> "$test_data_dir"/pacman-actions.txt
				else
					FatalError 'Mocked pacman --database without --asdeps/--asexplicit\n'
				fi
			done
			;;
		remove)
			local arg
			for arg in "${args[@]}"
			do
				printf 'remove %s\n' "$arg" >> "$test_data_dir"/pacman-actions.txt
				sed -i "$(printf "/%q/d" "$arg")" "$test_data_dir"/packages.txt
			done
			;;
		*)
			FatalError 'Unknown command %s\n' "$command"
			;;
	esac
}

pacman "$@"

Exit 0
